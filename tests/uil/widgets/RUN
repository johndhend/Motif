#!/bin/csh
# @OPENGROUP_COPYRIGHT@
# COPYRIGHT NOTICE
# Copyright (c) 1990, 1991, 1992, 1993 Open Software Foundation, Inc.
# Copyright (c) 1996, 1997, 1998, 1999, 2000 The Open Group
# ALL RIGHTS RESERVED (MOTIF). See the file named COPYRIGHT.MOTIF for
# the full copyright text.
# 
# This software is subject to an open license. It may only be
# used on, with or for operating systems which are themselves open
# source systems. You must contact The Open Group for a license
# allowing distribution and sublicensing of this software on, with,
# or for operating systems which are not Open Source programs.
# 
# See http://www.opengroup.org/openmotif/license for full
# details of the license agreement. Any use, reproduction, or
# distribution of the program constitutes recipient's acceptance of
# this agreement.
# 
# EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS
# PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION, ANY
# WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY
# OR FITNESS FOR A PARTICULAR PURPOSE
# 
# EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER RECIPIENT
# NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE
# EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGES.
#
# HISTORY



#!/bin/csh
# a known restriction of this script is that the arguments to -xrm (or
# any other flag!) must contain no spaces.

# revision history
#     11/21/91 libby    always output RUN_ouput and move $status check
#    12/21/91 libby    pass through flags to tests and change meaning
#            of modes (now: "compare" by default; "record = -r";
#            "nocompare = -c"
#    12/31/91 libby    quote "$arglist"
#    12/31/91 msr    remove this unexplainable quote
#    1/17/92     libby    modify msr's date and remove unneeded code re .prt's





#
# XFILESEARCHPATH mechanism for using the defaults file in each directory.
# First check to see if the variable is already set. If it is, save it.
# The, set XFILESEARCHPATH to $cwd/$cwd:t.defaults.
#

printenv XFILESEARCHPATH
if ($status == 0) then
	set Storepath = $XFILESEARCHPATH
	set pathExists = true
endif
setenv XFILESEARCHPATH $cwd/$cwd:t.defaults



# default vars

onintr Cleanup

set mode = compare
set Vistarun = false
set totalVista = false


#
# The following are Purify RUN related variables
#
# The format for specifying will be as follows:
#
#    RUN -memory <memory_switch>
#
# The various values of "memory_switch" and their meanings are as follows:
#
#     -all    - Log the complete Purify output
#     -leaks  - Log only memoryleaks
#     -fm     - Log only Freed Memory Read (Write) access errors
#     -um     - Log only Uninintialized Memory Read (Write) access errors
#     -ab     - Log only Array Bound Read (Write) access errors
#     -fu     - Log only Freed and Uninintialized Memory access errors
#     -fa     - Log only Freed and Array Bound Memory access errors
#     -ua     - Log only Uninintialized and Array Bound Memory access errors
#     -nocopy - Don't copy a .purify file in your current directory. If you 
#	        have a customized .purify in your current directory, it will 
#		use it, else it will act as -all.
#
# All of the above will have memory leak information along with the
# specified information. Memory leak information will need to be
# stripped out with all the cases other than "-all" and "-leaks"
#

set Purifyrun = false
set memoryInfo = "-all"


# The following are report generation related RUN variables.
# The format for specifying will be as follows:
#
#    RUN -genrep <report_switch>

#     -Dir	-Generates a directory level report
#     -test     -Generates a test level report
#     -panel    -Generates a panel level report
#
#

set Reportrun = false
set reportInfo = "-test"


set argcnt = $#argv
set argindex = 1
while ($argcnt != 0)
	switch ($argv[$argindex])
        case -r*:
            set mode = record
            breaksw
        case -c*:
            set mode = nocompare
            breaksw
        case -bfa*:
            set Vistarun = true
            set argv[$argindex] = ""
            breaksw
        case -BFA*:
            set Vistarun = true
            set totalVista = true
            set argv[$argindex] = ""
            breaksw
        case -memory:
            set Purifyrun = true
            set argv[$argindex] = ""
            @ argcnt--
            @ argindex++
            set memoryInfo = $argv[$argindex]
            set argv[$argindex] = ""
            breaksw
        case -d*:
            @ argcnt--
            @ argindex++
            setenv DISPLAY $argv[$argindex]
            breaksw
	case -genrep:
            set Reportrun = true
            set argv[$argindex] = ""
            @ argcnt--
            @ argindex++
            set reportInfo = $argv[$argindex]
            set argv[$argindex] = ""
            breaksw

    endsw
    @ argcnt--
    @ argindex++
end

set arglist = "$argv"

# Counter used for setting up Purify environment first time around
@ count = 0
@ Total_Test_Num = 0

echo "Mode is " $mode
if ($Vistarun == true) then
    echo "This is a Vista RUN"
endif

# clean up from previous runs

if (-e ./RUN_failures) then
    echo "backing up RUN_failures file"
    mv RUN_failures RUN_failures.bak
endif

touch RUN_failures

if (-e ./RUN_output) then
    echo "backing up output file"
    mv RUN_output RUN_output.bak
endif
touch RUN_output

if (-e .TotalTests) then
	rm -f .TotalTests
endif
touch .TotalTests

rm -f core
if ($Vistarun == true) then
    ls *.metg >& /dev/null
    if ($status == 0) then
        rm -f *.metg
    endif
    ls *.audg >& /dev/null
    if ($status == 0) then
        rm -f *.audg
    endif
    ls *.covg >& /dev/null
    if ($status == 0) then
        rm -f *.covg
    endif
endif


# set the path so that scripts for report generation can be read

set path = (/project/motif/qa/qauser/qatools/auto_rep $path)

# noglob is needed to handle special cases

set noglob

# special cases. Specify ALL flags for tests which require them.
# remember all arguments MUST be a single word (ie no spaces)
# use single quotes around the right side.

# START CUSTOMIZE # 

# $XConsortium: RUN.custom /main/6 1996/10/24 16:10:17 jakku $
# @OPENGROUP_COPYRIGHT@
# COPYRIGHT NOTICE
# Copyright (c) 1990, 1991, 1992, 1993 Open Software Foundation, Inc.
# Copyright (c) 1996, 1997, 1998, 1999, 2000 The Open Group
# ALL RIGHTS RESERVED (MOTIF). See the file named COPYRIGHT.MOTIF for
# the full copyright text.
# 
# This software is subject to an open license. It may only be
# used on, with or for operating systems which are themselves open
# source systems. You must contact The Open Group for a license
# allowing distribution and sublicensing of this software on, with,
# or for operating systems which are not Open Source programs.
# 
# See http://www.opengroup.org/openmotif/license for full
# details of the license agreement. Any use, reproduction, or
# distribution of the program constitutes recipient's acceptance of
# this agreement.
# 
# EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS
# PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION, ANY
# WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY
# OR FITNESS FOR A PARTICULAR PURPOSE
# 
# EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER RECIPIENT
# NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE
# EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGES.
#
# HISTORY

setenv AUTOVPATH /proj/motif/tests/visuals/uil/widgets

# The following needed for Vista usage

setenv TOP ../../..


set displayUid1 = 'displayUid -u BBoard -I BBoard.Dat -S BBoard.Scr -O BBoard.prt -V BBoard.vis'
set displayUid2 = 'displayUid -u BBoardDia -I BBoardDia.Dat -S BBoardDia.Scr -O BBoardDia.prt -V BBoardDia.vis'
set displayUid4 = 'displayUid -u  arrowBGad -I arrowBGad.Dat -S arrowBGad.Scr -O arrowBGad.prt -V arrowBGad.vis'
set displayUid5 = 'displayUid -u  arrowBtn -I arrowBtn.Dat -S arrowBtn.Scr -O arrowBtn.prt -V arrowBtn.vis'

set displayUid6 = 'displayUid -u  cascBGad -I cascBGad.Dat -S cascBGad.Scr -O cascBGad.prt -V cacsBGad.vis'
set displayUid7 = 'displayUid -u  cascBtn -I cascBtn.Dat -S cascBtn.Scr -O cascBtn.prt -V cascBtn.vis'
set displayUid8 = 'displayUid -u command -I command.Dat -S command.Scr -O command.prt -V command.vis'
set displayUid9 = 'displayUid -u diaShell -I diaShell.Dat -S diaShell.Scr -O diaShell.prt -V diaShell.vis'
set displayUid10 = 'displayUid -u drawArea -I drawArea.Dat -S drawArea.Scr -O drawArea.prt -V drawArea.vis'

set displayUid11 = 'displayUid -u errorDia -I errorDia.Dat -S errorDia.Scr -O errorDia.prt -V errorDia.vis'
set displayUid12 = 'displayUid -u form -I form.Dat -S form.Scr -O form.prt -V form.vis'
set displayUid13 = 'displayUid -u formDia -I formDia.Dat -S formDia.Scr -O formDia.prt -V formDia.vis'
set displayUid14 = 'displayUid -u frame -I frame.Dat -S frame.Scr -O frame.prt -V frame.vis'
set displayUid15 = 'displayUid -u fsBox -I fsBox.Dat -S fsBox.Scr -O fsBox.prt -V fsBox.vis'

set displayUid16 = 'displayUid -u fsDia -I fsDia.Dat -S fsDia.scr -O fsDia.prt -V fsDia.vis'
set displayUid17 = 'displayUid -u icon -I icon.Dat -S icon.Scr -O icon.prt -V icon.vis'
set displayUid18 = 'displayUid -u infoDia -I infoDia.Dat -S infoDia.Scr -O infoDia.prt -V infoDia.vis'
set displayUid20 = 'displayUid -u labelGad -I labelGad.Dat -S labelGad.Scr -O labelGad.prt -V labelGad.vis'

set displayUid21 = 'displayUid -u listBs -I listBs.Dat -S listBs.Scr -O listBs.prt -V listBs.vis'
set displayUid22 = 'displayUid -u listEs -I listEs.Dat -S listEs.Scr -O listEs.prt -V listEs.vis'
set displayUid23 = 'displayUid -u listSs -I listSs.Dat -S listSs.Scr -O listSs.prt -V listSs.vis'
set displayUid24 = 'displayUid -u listMs -I listMs.Dat -S listMs.Scr -O listMs.prt -V listMs.vis'
set displayUid25 = 'displayUid -u menuBar -I menuBar.Dat -S menuBar.Scr -O menuBar.prt -V menuBar.vis'

set displayUid26 = 'displayUid -u menuShell -I menuShell.Dat -S menuShell.Scr -O menuShell.prt -V menuShell.vis'
set displayUid27 = 'displayUid -u mesBox -I mesBox.Dat -S mesBox.Scr -O mesBox.prt -V mesBox.vis'
set displayUid28 = 'displayUid -u mesDia -I mesDia.Dat -S mesDia.Scr -O mesDia.prt -V mesDia.vis'
set displayUid29 = 'displayUid -u optionMenu -I optionMenu.Dat -S optionMenu.Scr -O optionMenu.prt -V optionMenu.vis'
set displayUid30 = 'displayUid -u panedWin -I panedWin.Dat -S panedWin.Scr -O panedWin.prt -V panedWin.vis'

set displayUid31 = 'displayUid -u popupMenu -I popupMenu.Dat -S popupMenu.Scr -O popupMenu.prt -V popupMenu.vis'
set displayUid32 = 'displayUid -u promptDia -I promptDia.Dat -S promptDia.Scr -O promptDia.prt -V promptDia.vis'
set displayUid33 = 'displayUid -u pulldown -I pulldown.Dat -S pulldown.Scr -O pulldown.prt -V pulldown.vis'
set displayUid34 = 'displayUid -u pushBGad -I pushBGad.Dat -S pushBGad.Scr -O pushBGad.prt -V pushBGad.vis'

set displayUid36 = 'displayUid -u radioBox -I radioBox.Dat -S radioBox.Scr -O radioBox.prt -V radioBox.vis'
set displayUid37 = 'displayUid -u rowCol -I rowCol.Dat -S rowCol.Scr -O rowCol.prt -V rowCol.vis'
set displayUid38 = 'displayUid -u scaleHorz -I scaleHorz.Dat -S scaleHorz.Scr -O scaleHorz.prt -V scaleHorz.vis'
set displayUid39 = 'displayUid -u scaleVert -I scaleVert.Dat -S scaleVert.Scr -O scaleVert.prt -V scaleVert.vis'
set displayUid40 = 'displayUid -u scrollLis2 -I scrollLis2.Dat  -S scrollLis2.Scr -O scrollLis2.prt -V scrollLis2.vis' 

set displayUid41 = 'displayUid -u scrollList -I scrollList.Dat -S scrollList.Scr -O scrollList.prt -V scrollList.vis'
set displayUid42 = 'displayUid -u scrollText -I scrollText.Dat -S scrollText.Scr -O scrollText.prt -V scrollText.vis'
set displayUid43 = 'displayUid -u scrollWin -I scrollWin.Dat -S scrollWin.Scr -O scrollWin.prt -V scrollWin.vis'
set displayUid44 = 'displayUid -u scrollWin2 -I scrollWin2.Dat -S scrollWin2.Scr -O scrollWin2.prt -V scrollWin2.vis'
set displayUid45 = 'displayUid -u scrollbarH -I scrollbarH.Dat -S scrollbarH.Scr -O scrollbarH.prt -V scrollbarH.vis'

set displayUid46 = 'displayUid -u scrollbarV -I scrollbarH.Dat -S scrollbarV.Scr -O scrollbarV.prt -V scrollbarV.vis'
set displayUid47 = 'displayUid -u warningDia -I warningDia.Dat -S warningDia.Scr -O warningDia.prt -V warningDia.vis'
set displayUid48 = 'displayUid -u workingDia -I workingDia.Dat -S workingDia.Scr -O workingDia.prt -V workingDia.vis'
set displayUid49 = 'displayUid -u selectBox -I selectBox.Dat -S selectBox.Scr -O selectBox.prt -V selectBox.vis'
set displayUid50 = 'displayUid -u selectDia -I selectDia.Dat -S selectDia.Scr -O selectDia.prt -V selectDia.vis'

set displayUid51 = 'displayUid -u templateDia -I templateDia.Dat -S templateDia.Scr -O templateDia.prt -V templateDia.vis'
set displayUid52 = 'displayUid -u textMl -I textMl.Dat -S textMl.Scr -O textMl.prt -V textMl.vis'
set displayUid53 = 'displayUid -u textSl -I textSl.Dat -S textSl.Scr -O textSl.prt -V textSl.vis'
set displayUid54 = 'displayUid -u toggleBtn -I toggleBtn.Dat -S toggleBtn.Scr -O toggleBtn.prt -V toggleBtn.vis'
set displayUid55 = 'displayUid -u toggleBGad -I toggleBGad.Dat -S toggleBGad.Scr -O toggleBGad.prt -V toggleBGad.vis'
set displayUid56 = 'displayUid -u drawnBtn -I drawnBtn.Dat -S drawnBtn.Scr -O drawnBtn.prt -V drawnBtn.vis'

set displayUid57 = 'displayUid -u pulldown2 -I pulldown2.Dat -S pulldown2.Scr -O pulldown2.prt -V pulldown2.vis'


set displayUid58 = 'displayUid -u iconGad -I iconGad.Dat -S iconGad.Scr -O iconGad.prt -V iconGad.vis'


set displayUid59 = 'displayUid -u spinBox -I spinBox.Dat -S spinBox.Scr -O spinBox.prt -V spinBox.vis'

set displayUid60 = 'displayUid -u comboBox -I comboBox.Dat -S comboBox.Scr -O comboBox.prt -V comboBox.vis'

foreach test ("$displayUid1" "$displayUid2" "$displayUid4" "$displayUid5" "$displayUid6" "$displayUid7" "$displayUid8" "$displayUid9" "$displayUid10" "$displayUid11" "$displayUid12" "$displayUid13" "$displayUid14" "$displayUid15" "$displayUid16" "$displayUid17" "$displayUid18" "$displayUid20" "$displayUid21" "$displayUid22" "$displayUid23" "$displayUid24" "$displayUid25" "$displayUid26" "$displayUid27" "$displayUid28" "$displayUid29" "$displayUid30" "$displayUid31" "$displayUid32" "$displayUid33" "$displayUid34" "$displayUid36" "$displayUid37" "$displayUid38" "$displayUid39" "$displayUid40" "$displayUid41" "$displayUid42" "$displayUid43" "$displayUid44" "$displayUid45" "$displayUid46" "$displayUid47" "$displayUid48" "$displayUid49" "$displayUid50" "$displayUid51" "$displayUid52" "$displayUid53" "$displayUid54" "$displayUid55" "$displayUid56" "$displayUid57""$displayUid58" "$displayUid59" "$displayUid60" )








# END CUSTOMIZE #
    
if ($count == 0 && $Purifyrun == true) then
    if (-e .purify.bak) then
        rm -f .purify.bak
    endif
    if ($memoryInfo == -nocopy) then
        if (-e .purify) then
	   echo "Using the local .purify" >> RUN_output
	endif
    else
        if (-e .purify) then
           mv .purify .purify.bak
	endif
    endif
    echo "This is a Purify RUN" >> RUN_output
    if ($mode == compare) then
        echo "No .prt comparison will be done at the end" >> RUN_output
    endif
    switch($memoryInfo)
        case -all:
            cp $TOP/tests/memory/.purify.all .purify
            breaksw
        case -fm:
            cp $TOP/tests/memory/.purify.fm .purify
            breaksw
        case -um:
            cp $TOP/tests/memory/.purify.um .purify
            breaksw
        case -ab:
            cp $TOP/tests/memory/.purify.ab .purify
            breaksw
        case -leaks:
            cp $TOP/tests/memory/.purify.leaks .purify
            breaksw
        case -fu:
            cp $TOP/tests/memory/.purify.fu .purify
            breaksw
        case -fa:
            cp $TOP/tests/memory/.purify.fa .purify
            breaksw
        case -ua:
            cp $TOP/tests/memory/.purify.ua .purify
            breaksw
    endsw
    @ count++
endif

    set test =($test)
	@ Total_Test_Num++
    
    foreach word ($test)
        if ($?name_flag) then
            set test_output = $word
            unset name_flag
        endif
        if ("$word" =~ "-O") then
            set name_flag = 1
        endif
    end

    if ($Vistarun == true) then
        if !(-e $TOP/tests/Vista/libXm.M) then
            echo "Map file libXm.M not found in $TOP/tests/Vista" >> RUN_output
            echo "No Vista reports generated" >> RUN_output
            set Vistarun = false
        endif
    endif
    if ($Vistarun == true) then
        set testname = `echo $test | awk '{print $1}'`
    endif
    if ($Purifyrun == true) then
		if ($?test_output) then
            set testname = `echo $test_output | awk -F'.' '{print $1}'`
		else
            set testname = `echo $test | awk '{print $1}'`
		endif
    endif

    if ($Purifyrun == true) then
        if (-e $testname.purify) then
            mv -f $testname.purify $testname.purify.bak
        endif
        setenv PURIFYLOGFILE $testname.purify
    endif

    echo "" >> RUN_output
    echo "Beginning test " $test[1] >> RUN_output
    echo "Beginning test " $test[1]
#
# If totalVista == true, only one "hits" file will be generated for the
# whole directory and a total coverage report for the directory as a whole
# will be generated
#
    if ($Vistarun == true && $totalVista == false) then
        set HIT_FILE = $TOP/tests/Vista/$testname.hits
        if (-e ${HIT_FILE}) then
               rm -f ${HIT_FILE}
        endif
    endif

    if ($Purifyrun == true) then
        if (-e $testname.purify) then
            rm -f $testname.purify
        endif
        setenv PURIFYLOGFILE $testname.purify
    endif

    if ($?test_output) then
        echo "Output redirected to " $test_output
        echo "Output redirected to " $test_output >> RUN_output
    endif

# try to prevent it quitting if the test wasn't built
    if (-e $test[1]) then
        echo "Running " $test $arglist
        $test $arglist
        if ($status != 0) then
            if (-e core) then
                echo "backing up core to "$test[1]".core"
                mv core $test[1].core
            endif
            echo "failure in test: "$test[1] >> RUN_failures
            echo "FAILURE IN TEST: "$test[1] >> RUN_output
            echo "FAILURE IN TEST: "$test[1] 
        else if ($Vistarun == true && $totalVista == false) then
            if (-e hits) then
                mv hits ${HIT_FILE}

                if (-e $testname.metg) then

                    MetGen $TOP/tests/Vista/libXm.M \
                    ./$testname.M >> $testname.metg

                    AudGen -T $testname.tally $TOP/tests/Vista/libXm.M \
                    ./$testname.M \
                    ${HIT_FILE} >> $testname.audg

                    CovGen $TOP/tests/Vista/libXm.M \
                    ./$testname.M \
                    $testname.tally >> $testname.covg
                else

                    MetGen $TOP/tests/Vista/libXm.M \
                    ./$testname.M > $testname.metg

                    AudGen -T $testname.tally $TOP/tests/Vista/libXm.M \
                    ./$testname.M \
                    ${HIT_FILE} > $testname.audg

                    CovGen $TOP/tests/Vista/libXm.M \
                    ./$testname.M \
                    $testname.tally > $testname.covg

                endif
                rm ${HIT_FILE}
                rm $testname.tally
            endif
            unset HIT_FILE
            unset testname
        else if ($Purifyrun == true) then
            unsetenv PURIFYLOGFILE
        endif
    else
        echo "Error - Test " $test " does not exist."
          echo "Error - Test " $test " does not exist" >> RUN_output
        continue
    endif

#we only need to do this in compare and manual modes
        if ($mode != record) then
      if ($?test_output) then
        cat $test_output >> RUN_output
      else
         cat $test[1].prt >> RUN_output
      endif
        endif
           echo "Ending test "$test[1]"" >> RUN_output
    echo "" >> RUN_output
        echo "Ending test "$test[1]""
    echo ""
    unset test_output

end

unset noglob
#
# if totalVista is true, generate the overall coverage report for the 
# directory
#
if ($Vistarun == true && $totalVista == true) then
    set dirname = `echo $cwd | awk -F '/' '{print $NF}'`
    if (-e hits) then
        MetGen $TOP/tests/Vista/libXm.M *.M > $dirname.metg

        AudGen -T $dirname.tally $TOP/tests/Vista/libXm.M *.M \
        hits > $dirname.audg

        CovGen $TOP/tests/Vista/libXm.M *.M $dirname.tally > $dirname.covg

    else
        echo "No hits file generated"
    endif
endif

# the .prt files are now automatically written in $AUTOVPATH in record mode

if ($mode == compare) then
    if ($Purifyrun == false) then
#compare number of *.prt files in both places only if not Purify RUN
        set prts_here = `ls -l ./*.prt | wc -l`
        set prts_there = `ls -l $AUTOVPATH/*.prt | wc -l`
        if ($prts_here > $prts_there) then
            echo "There are .prt files missing in " $AUTOVPATH >> RUN_failures
            echo "There are .prt files missing in " $AUTOVPATH 
        else if ($prts_there > $prts_here) then
            echo "There are .prt files missing in " $cwd >> RUN_failures
            echo "There are .prt files missing in " $cwd 
        endif
        foreach file ($AUTOVPATH/*.prt)
            if (-e $cwd/$file:t) then
                diff $file $cwd/$file:t > $file:t.diff
                    mv $file:t.diff $file:t.err
	    else
                echo "No "$file:t file found in $AUTOVPATH >> RUN_output
                echo "No "$file:t file found in $AUTOVPATH 
            endif
        end
    endif
endif

#
# If Purifyrun, Generate memory related reports
#
if ($Purifyrun == true) then
    GetLeaks
endif

Cleanup:
# remove empty .err files of no interest

if ($mode != nocompare) then
   set num_errfiles = `ls -l *.err | wc -l`
   if ($num_errfiles) then
       foreach errfile (*.err)
           sed -e '/^$/d' $errfile > $errfile.stp
           rm $errfile
           if !(-z $errfile.stp) then
               mv $errfile.stp $errfile
           else
               rm $errfile.stp
           endif
       end
   endif

   echo "Automated run of directory" $cwd:t " complete" >> RUN_output

endif


# if Reportrun is true, generate reports of the appropriate level.


if ($Reportrun == true) then
    echo "This is a Report RUN" >> RUN_output
    switch($reportInfo)
        case -Dir:
            run_dir $cwd
            breaksw
        case -test:
            foreach difffile ($cwd/*.err)
		run_test -file $difffile
	    end
            breaksw
        case -panel:
            foreach difffile ($cwd/*.err)
		run_panel $difffile
	    end
            breaksw
    endsw
endif

#
# If Vista build but not Vista report generating RUN, remove hits file
#
if (-e hits) then
    rm -f hits
endif

echo $Total_Test_Num >> .TotalTests

# Reset XFILESEARCHPATH

if (pathExists == true) then
	setenv XFILESEARCHPATH $Storepath
else
	unsetenv XFILESEARCHPATH
endif
	

exit 0 
