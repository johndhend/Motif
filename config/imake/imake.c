
#include <localdef.h>

/*
 * new: getting hacky and dated, so cleaned up toward original
 *      if you need arguments there is a "cannot fail"
 *      place to put them in below:  find cpp43  and look
 * fixit_argv[ARGUMENTS] = {"/bin/sh","/tmp/fix_makefile.sh"};
 *      will, if found, be run to fix final Makefile problems
 *      just before make(1) first sees the file
 * DEFAULT_CPP  and etc is  in  imakemdep.h  because ../makedep/
 *      will also #includ3 it in
 */

/*
 * 
 * 
 * Original Author:
 *	Todd Brunhoff
 *	Tektronix, inc.
 *	While a guest engineer at Project Athena, MIT
 *
 * imake: the include-make program.
 *
 * Usage: imake [-Idir] [-Ddefine] [-T template] [-f imakefile ] [-C Imakefile.c ] [-s] [-e] [-v] [make flags]
 *
 * Imake takes a template file (Imake.tmpl) and a prototype (Imakefile)
 * and runs cpp on them producing a Makefile.  It then optionally runs make
 * on the Makefile.
 * Options:
 *		-D	define.  Same as cpp -D argument.
 *		-I	Include directory.  Same as cpp -I argument.
 *		-T	template.  Designate a template other
 *			than Imake.tmpl
 *		-f	specify the Imakefile file
 *		-C	specify the name to use instead of Imakefile.c
 *		-s[F]	show.  Show the produced makefile on the standard
 *			output.  Make is not run is this case.  If a file
 *			argument is provided, the output is placed there.
 *              -e[F]   execute instead of show; optionally name Makefile F
 *		-v	verbose.  Show the make command line executed.
 *
 * Environment variables:
 *		
 *		IMAKEINCLUDE	Include directory to use in addition to "."
 *		IMAKECPP	Cpp to use instead of /lib/cpp
 *		IMAKEMAKE	make program to use other than what is
 *				found by searching the $PATH variable.
 * Other features:
 *	imake reads the entire cpp output into memory and then scans it
 *	for occurences of "@@".  If it encounters them, it replaces it with
 *	a newline.  It also trims any trailing white space on output lines
 *	(because make gets upset at them).  This helps when cpp expands
 *	multi-line macros but you want them to appear on multiple lines.
 *	It also changes occurences of "XCOMM" to "#", to avoid problems
 *	with treating commands as invalid preprocessor commands.
 *
 *	The macros MAKEFILE and MAKE are provided as macros
 *	to make.  MAKEFILE is set to imake's makefile (not the constructed,
 *	preprocessed one) and MAKE is set to argv[0], i.e. the name of
 *	the imake program.
 *
 * Theory of operation:
 *   1. Determine the name of the imakefile from the command line (-f)
 *	or from the content of the current directory (Imakefile or imakefile).
 *	Call this <imakefile>.  This gets added to the arguments for
 *	make as MAKEFILE=<imakefile>.
 *   2. Determine the name of the template from the command line (-T)
 *	or the default, Imake.tmpl.  Call this <template>
 *   3. Determine the name of the imakeCfile from the command line (-C)
 *	or the default, Imakefile.c.  Call this <imakeCfile>
 *   4. Store lines of input into <imakeCfile>:
 *	- A c-style comment header (see ImakefileCHeader below), used
 *	  to recognize temporary files generated by imake.
 *	- If the file "localdefines" is readable in the current
 *	  directory, print a warning message to stderr and add: 
 *		#define IMAKE_LOCAL_DEFINES	"localdefines"
 *		#include IMAKE_LOCAL_DEFINES
 *	- If the file "admindefines" is readable in the current
 *	  directory, print a warning message to stderr and add: 
 *		#define IMAKE_ADMIN_DEFINES	"admindefines"
 *		#include IMAKE_ADMIN_DEFINES
 *	- The following lines:
 *		#define INCLUDE_IMAKEFILE	< <imakefile> >
 *		#define IMAKE_TEMPLATE		" <template> "
 *		#include IMAKE_TEMPLATE
 *	- If the file "adminmacros" is readable in the current
 *	  directory, print a warning message to stderr and add: 
 *		#define IMAKE_ADMIN_MACROS	"adminmacros"
 *		#include IMAKE_ADMIN_MACROS
 *	- If the file "localmacros" is readable in the current
 *	  directory, print a warning message to stderr and add: 
 *		#define IMAKE_LOCAL_MACROS	"localmacros"
 *		#include IMAKE_LOCAL_MACROS
 *   5. Start up cpp and provide it with this file.
 *	Note that the define for INCLUDE_IMAKEFILE is intended for
 *	use in the template file.  This implies that the imake is
 *	useless unless the template file contains at least the line
 *		#include INCLUDE_IMAKEFILE
 *   6. Gather the output from cpp, and clean it up, expanding @@ to
 *	newlines, stripping trailing white space, cpp control lines,
 *	and extra blank lines, and changing XCOMM to #.  This cleaned
 *	output is placed in a new file, default "Makefile", but can
 *	be specified with -s or -e options.
 *   7. Optionally start up make on the resulting file.
 *
 * The design of the template makefile should therefore be:
 *	<set global macros like CFLAGS, etc.>
 *	<include machine dependent additions>
 *	#include INCLUDE_IMAKEFILE
 *	<add any global targets like 'clean' and long dependencies>
 */


#include <stdio.h>
#include "Xosdefs.h"
#ifndef X_NOT_STDC_ENV
#include <string.h>
#endif
#include <ctype.h>
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#if !defined(SIGCHLD) && defined(SIGCLD)
#define SIGCHLD		SIGCLD
#endif
#include <sys/stat.h>
#include <stdlib.h>
#define USE_STRERROR		1
#include <string.h>
#include <errno.h>

/*  
 *  TODO
 *
 *  these may cause problems; perhaps forking and waiting
 *  child to return should be removed for something simpler
 *     maybe use ps(1) to see if cpp has exited or not fork
 *     at all if fork isn't absolutely required to keep ENV
 *  SIGCHLD is another problem child but so is using anything
 *     to attempt to store/restore ENV ... except a separate
 *     vars.cpp file ?
 */
#include <sys/wait.h>
typedef int            waitType;
#define waitCode(w)    WEXITSTATUS(w)
#define waitSig(w)     WTERMSIG(w)



#define HAS_MKSTEMP

#define	TRUE		1
#define	FALSE		0

/*
 * Some versions of cpp reduce all tabs in macro expansion to a single space.
 * In addition, the escaped newline may be replaced with a space instead of
 * being deleted.  Blech.
 */

typedef unsigned char boolean;

#include "imakemdep.h"

/* replaced by the actual program to exec */
/* add current directory to include path */

char           *cpp;
char           *tmpMakefile = "/tmp/Imf.XXXXXX";
char           *tmpImakefile = "/tmp/IIf.XXXXXX";

/* better not to tangle with relative paths - env is big
 * could simply a pointers from make_argv, but no
 */
char           *fixit_argv[ARGUMENTS] = {"/bin/sh","/tmp/fix_makefile.sh"};
boolean         fixit = TRUE;

int             make_argindex;
int             cpp_argindex;
char           *Imakefile = NULL;
char           *Makefile = "Makefile";
char           *Template = "Imake.tmpl";
char           *ImakefileC = "Imakefile.c";
boolean         haveImakefileC = FALSE;
char           *cleanedImakefile = NULL;
char           *program;
char *          FindImakefile();
char *          ReadLine();
char *          CleanCppInput();
char *          Strdup();
char *          Emalloc();
void            LogFatalI(), LogFatal(), LogMsg();

void            showit();
void            wrapup();
void            init();
void            AddMakeArg();
void            AddCppArg();
void            SetOpts();
void            CheckImakefileC();
void            cppit();
void            makeit();
void            CleanCppOutput();
boolean         isempty();
void            writetmpfile();
void            doit(FILE  *, char *, char **);

boolean         verbose = FALSE;
boolean         show = TRUE;

int
main(argc, argv)
    int             argc;
    char          **argv;
{
    FILE           *tmpfd;
    char            makeMacro[BUFSIZ];
    char            makefileMacro[BUFSIZ];

    program = argv[0];
    init();
    SetOpts(argc, argv);

    Imakefile = FindImakefile(Imakefile);

    CheckImakefileC(ImakefileC);

    if (Makefile)
    {
        tmpMakefile = Makefile;
        if ((tmpfd = fopen(tmpMakefile, "w+")) == NULL)
            LogFatal("Cannot create temporary file %s.", tmpMakefile);
    } else
    {
        int             fd;
        tmpMakefile = Strdup(tmpMakefile);
#ifndef HAS_MKSTEMP
        if (mktemp(tmpMakefile) == NULL ||
            (tmpfd = fopen(tmpMakefile, "w+")) == NULL)
        {
            LogFatal("Cannot create temporary file %s.", tmpMakefile);
        }
#else
        fd = mkstemp(tmpMakefile);
        if (fd == -1 || (tmpfd = fdopen(fd, "w+")) == NULL)
        {
            if (fd != -1)
            {
                unlink(tmpMakefile);
                close(fd);
            }
            LogFatal("Cannot create temporary file %s.", tmpMakefile);
        }
#endif
    }
    AddMakeArg("-f");
    AddMakeArg(tmpMakefile);
    sprintf(makeMacro, "MAKE=%s", program);
    AddMakeArg(makeMacro);
    sprintf(makefileMacro, "MAKEFILE=%s", Imakefile);
    AddMakeArg(makefileMacro);

    cleanedImakefile = CleanCppInput(Imakefile);

    /* 
     *  The .c may modified by env maccro by cppit first,
     *  cppit calls cpp, then a Makefile clean function after
     *  which is still useful (handles @@ from cf).  there was
     *  a broken Klouge() that didn't work for clang: removed
     *  RETURN:  cppit does not terminate imake on cpp return value
     */
    cppit(cleanedImakefile, Template, ImakefileC, tmpfd, tmpMakefile);

    /* call external script */
    {
      FILE           *xinFile;
      xinFile = fopen(fixit_argv[0], "r");
      if (xinFile == NULL)
      {
          fprintf(stderr,"Cannot open %s , no Makefile fixer", fixit_argv[0] );
      }
      else
      {
          fclose(xinFile);
          doit(NULL, fixit_argv[0], fixit_argv);
      }
    }

    if (show)
    {
        if (Makefile == NULL)
            showit(tmpfd);
    } else
        makeit();

    wrapup();
    exit(0);
}

void
showit(fd)
FILE * fd;
{
    char            buf[BUFSIZ];
    int             red;

    fseek(fd, 0, 0);
    while ((red = fread(buf, 1, BUFSIZ, fd)) > 0)
        writetmpfile(stdout, buf, red, "stdout");
    if (red < 0)
        LogFatal("Cannot read %s.", tmpMakefile);
}

/* 
 *  a way to see intermediates is to use fix_makefiles.sh
 */

void
wrapup()
{
    if (tmpMakefile != Makefile)
        unlink(tmpMakefile);
    if (cleanedImakefile && cleanedImakefile != Imakefile)
        unlink(cleanedImakefile);
    if (haveImakefileC)
        unlink(ImakefileC);
}

#ifdef SIGNALRETURNSINT
int
#else
void
#endif
catch(sig)
    int             sig;
{
    errno = 0;
    LogFatalI("Signal %d.", sig);
}

/*
 * Initialize some variables.
 */
void
init()
{
    register char  *p;

    make_argindex = 0;
    while (make_argv[make_argindex] != NULL)
        make_argindex++;
    cpp_argindex = 0;
    while (cpp_argv[cpp_argindex] != NULL)
        cpp_argindex++;

    /*
     * See if the standard include directory is different than the default.
     * Or if cpp is not the default.  Or if the make found by the PATH
     * variable is not the default.
     */
    if (p = getenv("IMAKEINCLUDE"))
    {
        if (*p != '-' || *(p + 1) != 'I')
            LogFatal("Environment var IMAKEINCLUDE %s",
                     "must begin with -I");
        AddCppArg(p);
        for (; *p; p++)
            if (*p == ' ')
            {
                *p++ = '\0';
                AddCppArg(p);
            }
    }
    if (p = getenv("IMAKECPP"))
        cpp = p;
    if (p = getenv("IMAKEMAKE"))
        make_argv[0] = p;

    if (signal(SIGINT, SIG_IGN) != SIG_IGN)
        signal(SIGINT, catch);
#ifdef SIGCHLD
    signal(SIGCHLD, SIG_DFL);
#endif

}

void
AddMakeArg(arg)
    char           *arg;
{
    errno = 0;
    if (make_argindex >= ARGUMENTS - 1)
        LogFatal("Out of internal storage.", "");
    make_argv[make_argindex++] = arg;
    make_argv[make_argindex] = NULL;
}

void
AddCppArg(arg)
    char           *arg;
{
    errno = 0;
    if (cpp_argindex >= ARGUMENTS - 1)
        LogFatal("Out of internal storage.", "");
    cpp_argv[cpp_argindex++] = arg;
    cpp_argv[cpp_argindex] = NULL;
}

void
SetOpts(argc, argv)
    int             argc;
    char          **argv;
{
    errno = 0;
    /*
     * Now gather the arguments for make
     */
    for (argc--, argv++; argc; argc--, argv++)
    {
        /*
         * We intercept these flags.
         */
        if (argv[0][0] == '-')
        {
            if (argv[0][1] == 'D')
            {
                AddCppArg(argv[0]);
            } else if (argv[0][1] == 'I')
            {
                AddCppArg(argv[0]);
            } else if (argv[0][1] == 'U')
            {
                AddCppArg(argv[0]);
            } else if (argv[0][1] == 'f')
            {
                if (argv[0][2])
                    Imakefile = argv[0] + 2;
                else
                {
                    argc--, argv++;
                    if (!argc)
                        LogFatal("No description arg after -f flag", "");
                    Imakefile = argv[0];
                }
            } else if (argv[0][1] == 's')
            {
                if (argv[0][2])
                    Makefile = ((argv[0][2] == '-') && !argv[0][3]) ?
                        NULL : argv[0] + 2;
                else
                {
                    argc--, argv++;
                    if (!argc)
                        LogFatal("No description arg after -s flag", "");
                    Makefile = ((argv[0][0] == '-') && !argv[0][1]) ?
                        NULL : argv[0];
                }
                show = TRUE;
            } else if (argv[0][1] == 'e')
            {
                Makefile = (argv[0][2] ? argv[0] + 2 : NULL);
                show = FALSE;
            } else if (argv[0][1] == 'T')
            {
                if (argv[0][2])
                    Template = argv[0] + 2;
                else
                {
                    argc--, argv++;
                    if (!argc)
                        LogFatal("No description arg after -T flag", "");
                    Template = argv[0];
                }
            } else if (argv[0][1] == 'C')
            {
                if (argv[0][2])
                    ImakefileC = argv[0] + 2;
                else
                {
                    argc--, argv++;
                    if (!argc)
                        LogFatal("No imakeCfile arg after -C flag", "");
                    ImakefileC = argv[0];
                }
            } else if (argv[0][1] == 'v')
            {
                verbose = TRUE;
            } else
                AddMakeArg(argv[0]);
        } else
            AddMakeArg(argv[0]);
    }

    if (!cpp)
        cpp = DEFAULT_CPP;

    cpp_argv[0] = cpp;
    AddCppArg(ImakefileC);

}

char *
FindImakefile(Imakefile)
    char           *Imakefile;
{
    if (Imakefile)
    {
        if (access(Imakefile, R_OK) < 0)
            LogFatal("Cannot find %s.", Imakefile);
    } else
    {
        if (access("Imakefile", R_OK) < 0)
            if (access("imakefile", R_OK) < 0)
                LogFatal("No description file.", "");
            else
                Imakefile = "imakefile";
        else
            Imakefile = "Imakefile";
    }
    return (Imakefile);
}

void
LogFatalI(s, i)
    char           *s;
    int             i;
{
    /* NOSTRICT */
    LogFatal(s, (char *)(long)i);
}

void
LogFatal(x0, x1)
    char           *x0, *x1;
{
    static boolean entered = FALSE;

    if (entered)
        return;
    entered = TRUE;

    LogMsg(x0, x1);
    fprintf(stderr, "  Stop.\n");
    wrapup();
    exit(1);
}

void
LogMsg(x0, x1)
    char           *x0, *x1;
{
    int             error_number = errno;

    if (error_number)
    {
        fprintf(stderr, "%s: ", program);
        fprintf(stderr, "%s\n", strerror(error_number));
    }
    fprintf(stderr, "%s: ", program);
    fprintf(stderr, x0, x1);
    fprintf(stderr, "\n");
}

void
showargs(argv)
    char          **argv;
{
    for (; *argv; argv++)
        fprintf(stderr, "%s ", *argv);
    fprintf(stderr, "\n");
}

#define ImakefileCHeader "/* imake - temporary file */"

void
CheckImakefileC(masterc)
    char           *masterc;
{
    char            mkcbuf[1024];
    FILE           *inFile;

    if (access(masterc, F_OK) == 0)
    {
        inFile = fopen(masterc, "r");
        if (inFile == NULL)
            LogFatal("Refuse to overwrite: %s", masterc);
        if ((fgets(mkcbuf, sizeof(mkcbuf), inFile) &&
             strncmp(mkcbuf, ImakefileCHeader,
                     sizeof(ImakefileCHeader) - 1)))
        {
            fclose(inFile);
            LogFatal("Refuse to overwrite: %s", masterc);
        }
        fclose(inFile);
    }
}

#ifndef INCLUDE_IMAKEFILE
#define INCLUDE_IMAKEFILE <Imakefile>
#endif

#define LocalDefineFmt	"#define %s \"%s\"\n"
#define IncludeFmt	"#include %s\n"
#define ImakeDefSym	"INCLUDE_IMAKEFILE"
#define ImakeTmplSym	"IMAKE_TEMPLATE"
#define INCLUDE_IMAKEFILE	"<Imakefile>"
#define IMAKE_TEMPLATE		"<Imake.tmpl>"
#define OverrideWarning	"Warning: local file \"%s\" overrides global macros."

boolean
optional_include(inFile, defsym, fname)
FILE * inFile;
char           *defsym;
char           *fname;
{
    errno = 0;
    if (access(fname, R_OK) == 0)
    {
        LogMsg(OverrideWarning, fname);
        return (fprintf(inFile, LocalDefineFmt, defsym, fname) < 0 ||
                fprintf(inFile, IncludeFmt, defsym) < 0);
    }
    return FALSE;
}

void
doit(outfd, cmd, argv)
FILE * outfd;
    char           *cmd;
    char          **argv;
{
    int             pid;
    waitType        status;

    /*
     * Fork and exec the command.
     */

    pid = fork();
    if (pid < 0)
        LogFatal("Cannot fork.", "");
    if (pid)
    {                           /* parent... simply wait */
        while (wait(&status) > 0)
        {
            errno = 0;
            if( fixit != TRUE )
            {
              if (WIFSIGNALED(status))
                  LogFatal("Signal %d.", waitSig(status));
              if (WIFEXITED(status) && waitCode(status))
                  LogFatal("Exit code %d.", waitCode(status));
            }
            else
              errno = 0;
        }
    } else
    {                           /* child... dup and exec cmd */
        if (verbose)
            showargs(argv);
        if (outfd)
            dup2(fileno(outfd), 1);

        {
            /*
             * Say BOOTSTRAPFLAGS doesnt work with your shell quoting or
             * something else clobbers it, like C "knowing your wrong system
             * type", use args here instead of argv, adjusting as you need.
             */

	    if( strstr(cmd, "cpp43") != NULL )
            {
              int i;
              char          * args[12];
              i=0;
              args[i++]="/usr/bin/cpp43";
              args[i++]="-P";
              args[i++]="-DXCOMM=#";
              args[i++]="-I/usr/X11/include";
              args[i++]="-I/usr/X11/include/X11";
              args[i++]="-I/usr/include";
              args[i++]="-I/usr/local/src/motif-2.5.0";
              args[i++]="-I/usr/local/src/motif-2.5.0/config";
              args[i++]="-I/usr/local/src/motif-2.5.0/config/cf";
              args[i++]="-I/usr/local/src/motif-2.5.0/include";
              args[i++]="Imakefile.c";
              args[11] = NULL;
            }

            execvp(cmd, argv);
        }
        LogFatal("Cannot exec %s.", cmd);
    }

}


#ifndef PATH_MAX
#define PATH_MAX 1024
#endif


void
cppit(imakefile, template, masterc, outfd, outfname)
    char           *imakefile;
    char           *template;
    char           *masterc;
    FILE           *outfd;
    char           *outfname;
{
    FILE           *inFile;

    haveImakefileC = TRUE;
    inFile = fopen(masterc, "w");
    if (inFile == NULL)
        LogFatal("Cannot open %s for output.", masterc);

    if (fprintf(inFile, "%s\n", ImakefileCHeader) < 0 ||
        optional_include(inFile, "IMAKE_LOCAL_DEFINES", "localdefines") ||
        optional_include(inFile, "IMAKE_ADMIN_DEFINES", "admindefines") ||
        fprintf(inFile, "#define %s <%s>\n", ImakeDefSym, imakefile) < 0 ||
        fprintf(inFile, LocalDefineFmt, ImakeTmplSym, template) < 0 ||
        fprintf(inFile, IncludeFmt, ImakeTmplSym) < 0 ||
        optional_include(inFile, "IMAKE_ADMIN_MACROS", "adminmacros") ||
        optional_include(inFile, "IMAKE_LOCAL_MACROS", "localmacros") ||
        fflush(inFile) ||
        fclose(inFile))
        LogFatal("Cannot write to %s.", masterc);
    /*
     * Fork and exec cpp
     */

    doit(outfd, cpp, cpp_argv);

    CleanCppOutput(outfd, outfname);

}

void
makeit()
{
    doit(NULL, make_argv[0], make_argv);
}

char *
CleanCppInput(imakefile)
    char           *imakefile;
{
    FILE           *outFile = NULL;
    FILE           *inFile;
    char           *buf,        /* buffer for file content */
                   *pbuf,       /* walking pointer to buf */
                   *punwritten, /* pointer to unwritten portion of buf */
                   *ptoken,     /* pointer to # token */
                   *pend,       /* pointer to end of # token */
                    savec;      /* temporary character holder */
    int             count;
    struct stat     st;

    /*
     * grab the entire file.
     */
    if (!(inFile = fopen(imakefile, "r")))
        LogFatal("Cannot open %s for input.", imakefile);
    if (fstat(fileno(inFile), &st) < 0)
        LogFatal("Cannot stat %s for size.", imakefile);
    buf = Emalloc((int)st.st_size + 3);
    count = fread(buf + 2, 1, st.st_size, inFile);
    if (count == 0 && st.st_size != 0)
        LogFatal("Cannot read %s:", imakefile);
    fclose(inFile);
    buf[0] = '\n';
    buf[1] = '\n';
    buf[count + 2] = '\0';

    punwritten = pbuf = buf + 2;
    while (*pbuf)
    {
        /* for compatibility, replace make comments for cpp */
        if (*pbuf == '#' && pbuf[-1] == '\n' && pbuf[-2] != '\\')
        {
            ptoken = pbuf + 1;
            while (*ptoken == ' ' || *ptoken == '\t')
                ptoken++;
            pend = ptoken;
            while (*pend && *pend != ' ' && *pend != '\t' && *pend != '\n')
                pend++;
            savec = *pend;
            *pend = '\0';
            if (strcmp(ptoken, "define") &&
                strcmp(ptoken, "if") &&
                strcmp(ptoken, "ifdef") &&
                strcmp(ptoken, "ifndef") &&
                strcmp(ptoken, "include") &&
                strcmp(ptoken, "line") &&
                strcmp(ptoken, "else") &&
                strcmp(ptoken, "elif") &&
                strcmp(ptoken, "endif") &&
                strcmp(ptoken, "error") &&
                strcmp(ptoken, "pragma") &&
                strcmp(ptoken, "undef"))
            {
                if (outFile == NULL)
                {
                    int             fd;
                    tmpImakefile = Strdup(tmpImakefile);
#ifndef HAS_MKSTEMP
                    if (mktemp(tmpImakefile) == NULL ||
                        (outFile = fopen(tmpImakefile, "w+")) == NULL)
                    {
                        LogFatal("Cannot open %s for write.",
                                 tmpImakefile);
                    }
#else
                    fd = mkstemp(tmpImakefile);
                    if (fd != -1)
                        outFile = fdopen(fd, "w");
                    if (outFile == NULL)
                    {
                        if (fd != -1)
                        {
                            unlink(tmpImakefile);
                            close(fd);
                        }
                        LogFatal("Cannot open %s for write.",
                                 tmpImakefile);
                    }
#endif
                }
                writetmpfile(outFile, punwritten, pbuf - punwritten,
                             tmpImakefile);
                if (ptoken > pbuf + 1)
                    writetmpfile(outFile, "XCOMM", 5, tmpImakefile);
                else
                    writetmpfile(outFile, "XCOMM ", 6, tmpImakefile);
                punwritten = pbuf + 1;
            }
            *pend = savec;
        }
        pbuf++;
    }
    if (outFile)
    {
        writetmpfile(outFile, punwritten, pbuf - punwritten, tmpImakefile);
        fclose(outFile);
        return tmpImakefile;
    }

    return (imakefile);
}

void
CleanCppOutput(tmpfd, tmpfname)
FILE * tmpfd;
    char           *tmpfname;
{
    char           *input;
    int             blankline = 0;

    while (input = ReadLine(tmpfd, tmpfname))
    {
        if (isempty(input))
        {
            if (blankline++)
                continue;
        } else
        {
            blankline = 0;
            writetmpfile(tmpfd, input, strlen(input), tmpfname);
        }
        writetmpfile(tmpfd, "\n", 1, tmpfname);
    }
    fflush(tmpfd);

    ftruncate (fileno(tmpfd), (off_t)ftell(tmpfd));
}

/*
 * Determine if a line has nothing in it.  As a side effect, we trim white
 * space from the end of the line.  Cpp magic cookies are also thrown away.
 * "XCOMM" token is transformed to "#".
 */
boolean
isempty(line)
register char  *line;
{
    register char  *pend;

    /*
     * Check for lines of the form # n "... or # line n "...
     */
    if (*line == '#')
    {
        pend = line + 1;
        if (*pend == ' ')
            pend++;
        if (*pend == 'l' && pend[1] == 'i' && pend[2] == 'n' &&
            pend[3] == 'e' && pend[4] == ' ')
            pend += 5;
        if (isdigit(*pend))
        {
            do
            {
                pend++;
            } while (isdigit(*pend));
            if (*pend == '\n' || *pend == '\0')
                return (TRUE);
            if (*pend++ == ' ' && *pend == '"')
                return (TRUE);
        }
        while (*pend)
            pend++;
    } else
    {
        for (pend = line; *pend; pend++)
        {
            if (*pend == 'X' && pend[1] == 'C' && pend[2] == 'O' &&
                pend[3] == 'M' && pend[4] == 'M' &&
                (pend == line || pend[-1] == ' ' || pend[-1] == '\t') &&
                (pend[5] == ' ' || pend[5] == '\t' || pend[5] == '\0'))
            {
                *pend = '#';
                strcpy(pend + 1, pend + 5);
            }
        }
    }
    while (--pend >= line && (*pend == ' ' || *pend == '\t'));
    pend[1] = '\0';
    return (*line == '\0');
}

/* ARGSUSED */
char *
ReadLine(tmpfd, tmpfname)
FILE * tmpfd;
    char           *tmpfname;
{
    static boolean initialized = FALSE;
    static char    *buf, *pline, *end;
    register char  *p1, *p2;

    if (!initialized)
    {
        int             total_red;
        struct stat     st;

        /*
         * Slurp it all up.
         */
        fseek(tmpfd, 0, 0);
        if (fstat(fileno(tmpfd), &st) < 0)
            LogFatal("cannot stat %s for size", tmpMakefile);
        pline = buf = Emalloc((int)st.st_size + 1);
        total_red = fread(buf, 1, st.st_size, tmpfd);
        if (total_red == 0 && st.st_size != 0)
            LogFatal("cannot read %s", tmpMakefile);
        end = buf + total_red;
        *end = '\0';

        fseek(tmpfd, 0, 0);
        /* set file length */
        ftruncate(fileno(tmpfd), (off_t) 0);

        initialized = TRUE;
        fprintf(tmpfd, "# Makefile generated by imake - do not edit!\n");
        fprintf(tmpfd, "# %s\n",
                "$TOG: imake.c /main/97 1997/06/20 20:23:51 kaleb $");
    }

    for (p1 = pline; p1 < end; p1++)
    {
        if (*p1 == '@' && *(p1 + 1) == '@'
        /* ignore ClearCase version-extended pathnames */
            && !(p1 != pline && !isspace(*(p1 - 1)) && *(p1 + 2) == '/'))
        {                       /* soft EOL */
            *p1++ = '\0';
            p1++;               /* skip over second @ */
            break;
        } else if (*p1 == '\n')
        {                       /* real EOL */
            *p1++ = '\0';
            break;
        }
    }

    /*
     * return NULL at the end of the file.
     */
    p2 = (pline == p1 ? NULL : pline);
    pline = p1;
    return (p2);
}

void
writetmpfile(fd, buf, cnt, fname)
FILE * fd;
    int             cnt;
    char           *buf;
    char           *fname;
{
    if (fwrite(buf, sizeof(char), cnt, fd) == -1)
        LogFatal("Cannot write to %s.", fname);
}

char *
Emalloc(size)
    int             size;
{
    char           *p;

    if ((p = malloc(size)) == NULL)
        LogFatalI("Cannot allocate %d bytes", size);
    return (p);
}


char *
Strdup(cp)
    register char  *cp;
{
    register char  *new = Emalloc(strlen(cp) + 1);

    strcpy(new, cp);
    return new;
}
